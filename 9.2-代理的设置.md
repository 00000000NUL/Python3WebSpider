# 代理的设置

在前面我们介绍了多种请求库，如Requests、Urllib、Selenium等。我们接下来首先贴近实战，了解一下代理怎么使用，为后面了解代理池、ADSL拨号代理的使用打下基础。

下面我们来梳理一下这些库的代理的设置方法。

## 获取代理

在做测试之前，我们需要先获取一个可用代理，搜索引擎搜索代理关键字，就可以看到有许多代理服务网站，在网站上会有很多免费代理，比如西刺，[http://www.xicidaili.com/](http://www.xicidaili.com/)，这里列出了很多免费代理，但是这些免费代理大多数情况下都是不好用的，所以比较靠谱的方法是购买付费代理，很多网站都有售卖，数量不用多，买一个稳定可用的即可，可以自行选购。

或者如果我们本机有相关代理软件的话，软件一般会在本机创建HTTP或SOCKS代理服务，直接使用此代理也可以。

在这里我的本机安装了一部代理软件，它会在本地9743端口上创建HTTP代理服务，也就是代理为127.0.0.1:9743，另外还会在9742端口创建SOCKS代理服务，也就是代理为127.0.0.1:9742，我只要设置了这个代理就可以成功将本机IP切换到代理软件连接的服务器的IP了。

所以以下示例里我们用上述代理来演示代理的设置方法，测试的网址是[http://httpbin.org/get](http://httpbin.org/get)，访问站点可以得到请求的一些相关信息，其中origin字段就是我们的IP，我们可以根据它来判断代理是否设置成功，也就是是否成功伪装了IP。

## Urllib

首先我们以最基础的Urllib为例，来看一下代理的设置方法。

```python
from urllib.error import URLError
from urllib.request import ProxyHandler, build_opener

proxy = '127.0.0.1:9743'
proxy_handler = ProxyHandler({
    'http': 'http://' + proxy,
    'https': 'https://' + proxy
})
opener = build_opener(proxy_handler)
try:
    response = opener.open('http://httpbin.org/get')
    print(response.read().decode('utf-8'))
except URLError as e:
    print(e.reason)

```

运行结果如下：

```json
{
  "args": {}, 
  "headers": {
    "Accept-Encoding": "identity", 
    "Connection": "close", 
    "Host": "httpbin.org", 
    "User-Agent": "Python-urllib/3.6"
  }, 
  "origin": "106.185.45.153", 
  "url": "http://httpbin.org/get"
}
```

在这里我们需要借助于ProxyHandler设置代理，参数是字典类型，键名为协议类型，键值是代理，注意此处代理前面需要加上协议，即http或者https，此处设置了http和https两种代理，当我们请求的链接是http协议的时候，它会调用http代理，当请求的链接是https协议的时候，它会调用https代理，所以此处生效的代理是`http://127.0.0.1:9743`。

创建完ProxyHandler对象之后，我们需要利用build_opener()方法传入该对象来创建一个Opener，这样就相当于此Opener已经设置好代理了，接下来直接调用它的open()方法即可使用此代理访问我们所想要的链接。

运行输出结果是一个Json，它有一个字段origin，标明了客户端的IP，此处的IP验证一下，确实为代理的IP，而并不是我们真实的IP，所以这样我们就成功设置好代理，并可以隐藏真实IP了。

如果遇到需要认证的代理，我们可以用如下的方法设置：

```python
from urllib.error import URLError
from urllib.request import ProxyHandler, build_opener

proxy = 'username:password@127.0.0.1:9743'
proxy_handler = ProxyHandler({
    'http': 'http://' + proxy,
    'https': 'https://' + proxy
})
opener = build_opener(proxy_handler)
try:
    response = opener.open('http://httpbin.org/get')
    print(response.read().decode('utf-8'))
except URLError as e:
    print(e.reason)
```

这里改变的只是proxy变量，只需要在代理前面加入代理认证的用户名密码即可，其中username就是用户名，password为密码，例如username为foo，密码为bar，那么代理就是`foo:bar@127.0.0.1:9743`。

如果代理是SOCKS5类型，那么可以用如下方式设置代理：

```python
import socks
import socket
from urllib import request
from urllib.error import URLError

socks.set_default_proxy(socks.SOCKS5, '127.0.0.1', 9742)
socket.socket = socks.socksocket
try:
    response = request.urlopen('http://httpbin.org/get')
    print(response.read().decode('utf-8'))
except URLError as e:
    print(e.reason)
```

此处需要一个socks模块，可以通过如下命令安装：

```
pip3 install PySocks
```

本地我有一个SOCKS5代理，运行在9742端口，运行成功之后和上文HTTP代理输出结果是一样的：

```json
{
  "args": {}, 
  "headers": {
    "Accept-Encoding": "identity", 
    "Connection": "close", 
    "Host": "httpbin.org", 
    "User-Agent": "Python-urllib/3.6"
  }, 
  "origin": "106.185.45.153", 
  "url": "http://httpbin.org/get"
}
```

结果的origin字段同样为代理的IP，设置代理成功。

## Requests

对于Requests来说，代理设置更加简单，我们只需要传入proxies参数即可。

还是以上例中的代理为例，我们来看下Requests的代理的设置：

```python
import requests

proxy = '127.0.0.1:9743'
proxies = {
    'http': 'http://' + proxy,
    'https': 'https://' + proxy,
}
try:
    response = requests.get('http://httpbin.org/get', proxies=proxies)
    print(response.text)
except requests.exceptions.ConnectionError as e:
    print('Error', e.args)
```

运行结果：

```json
{
  "args": {}, 
  "headers": {
    "Accept": "*/*", 
    "Accept-Encoding": "gzip, deflate", 
    "Connection": "close", 
    "Host": "httpbin.org", 
    "User-Agent": "python-requests/2.18.1"
  }, 
  "origin": "106.185.45.153", 
  "url": "http://httpbin.org/get"
}
```

可以发现Requests的代理设置比Urllib简单很多，只需要构造代理字典即可，然后通过proxies参数即可设置代理，不需要重新构建Opener。

可以发现其运行结果的origin也是代理的IP，证明代理已经设置成功。

如果代理需要认证，同样在代理的前面加上用户名密码即可，代理的写法就变成：

```python
proxy = 'username:password@127.0.0.1:9743'
```

和Urllib一样，只需要将username和password替换即可。

如果需要使用SOCKS5代理，则可以使用如下方式：

```python
import requests

proxy = '127.0.0.1:9742'
proxies = {
    'http': 'socks5://' + proxy,
    'https': 'socks5://' + proxy
}
try:
    response = requests.get('http://httpbin.org/get', proxies=proxies)
    print(response.text)
except requests.exceptions.ConnectionError as e:
    print('Error', e.args)
```

在这里需要额外安装一个模块，叫做`requests[socks]`，命令如下：

```
pip3 install 'requests[socks]'
```

运行结果是完全相同的：

```json
{
  "args": {}, 
  "headers": {
    "Accept": "*/*", 
    "Accept-Encoding": "gzip, deflate", 
    "Connection": "close", 
    "Host": "httpbin.org", 
    "User-Agent": "python-requests/2.18.1"
  }, 
  "origin": "106.185.45.153", 
  "url": "http://httpbin.org/get"
}
```

另外还有一种设置方式，和Urllib中的方法相同，使用socks模块，也需要像上文一样安装该库，设置方法如下：

```python
import requests
import socks
import socket

socks.set_default_proxy(socks.SOCKS5, '127.0.0.1', 9742)
socket.socket = socks.socksocket
try:
    response = requests.get('http://httpbin.org/get')
    print(response.text)
except requests.exceptions.ConnectionError as e:
    print('Error', e.args)
```

这样也可以设置SOCKS5代理，运行结果完全相同，相比第一种方法，此方法是全局设置，不同情况可以选用不同的方法。

## Selenium

Selenium同样也可以设置代理，在这里分两种介绍，一个是有界面浏览器，以Chrome为例介绍，另一种是无界面浏览器，以PhantomJS为例介绍。

### Chrome

对于Chrome来说，用Selenium设置代理的方法也非常简单，设置方法如下：

```python
from selenium import webdriver

proxy = '127.0.0.1:9743'
chrome_options = webdriver.ChromeOptions()
chrome_options.add_argument('--proxy-server=http://' + proxy)
browser = webdriver.Chrome(chrome_options=chrome_options)
browser.get('http://httpbin.org/get')
```

在这里我们通过ChromeOptions来设置代理，在创建Chrome对象的时候通过chrome_options参数传递即可。

这样在运行之后便会弹出一个Chrome浏览器，访问目标链接之后输出结果如下：

```json
{
  "args": {}, 
  "headers": {
    "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8", 
    "Accept-Encoding": "gzip, deflate", 
    "Accept-Language": "zh-CN,zh;q=0.8", 
    "Connection": "close", 
    "Host": "httpbin.org", 
    "Upgrade-Insecure-Requests": "1", 
    "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36"
  }, 
  "origin": "106.185.45.153", 
  "url": "http://httpbin.org/get"
}
```

可以看到origin同样为代理IP的地址，代理设置成功。

如果代理是认证代理，则设置方法相对比较麻烦，方法如下：

```python
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
import zipfile

ip = '127.0.0.1'
port = 9743
username = 'foo'
password = 'bar'

manifest_json = """
{
    "version": "1.0.0",
    "manifest_version": 2,
    "name": "Chrome Proxy",
    "permissions": [
        "proxy",
        "tabs",
        "unlimitedStorage",
        "storage",
        "<all_urls>",
        "webRequest",
        "webRequestBlocking"
    ],
    "background": {
        "scripts": ["background.js"]
    }
}
"""

background_js = """
var config = {
        mode: "fixed_servers",
        rules: {
          singleProxy: {
            scheme: "http",
            host: "%(ip)s",
            port: %(port)s
          }
        }
      }

chrome.proxy.settings.set({value: config, scope: "regular"}, function() {});

function callbackFn(details) {
    return {
        authCredentials: {
            username: "%(username)s",
            password: "%(password)s"
        }
    }
}

chrome.webRequest.onAuthRequired.addListener(
            callbackFn,
            {urls: ["<all_urls>"]},
            ['blocking']
)
""" % {'ip': ip, 'port': port, 'username': username, 'password': password}

plugin_file = 'proxy_auth_plugin.zip'
with zipfile.ZipFile(plugin_file, 'w') as zp:
    zp.writestr("manifest.json", manifest_json)
    zp.writestr("background.js", background_js)
chrome_options = Options()
chrome_options.add_argument("--start-maximized")
chrome_options.add_extension(plugin_file)
browser = webdriver.Chrome(chrome_options=chrome_options)
browser.get('http://httpbin.org/get')
```

在这里需要在本地创建一个manifest.json配置文件和background.js脚本来设置认证代理，运行之后本地会生成一个proxy_auth_plugin.zip文件保存配置。

运行结果和上例一致，origin同样为代理IP。

### PhantomJS

对于PhantomJS，代理设置方法可以借助于service_args参数，也就是命令行参数，代理设置方法如下：

```python
from selenium import webdriver

service_args = [
    '--proxy=127.0.0.1:9743',
    '--proxy-type=http'
]
browser = webdriver.PhantomJS(service_args=service_args)
browser.get('http://httpbin.org/get')
print(browser.page_source)
```

在这里我们只需要使用service_args参数，将命令行的一些参数定义为列表，在初始化的时候传递即可。

运行结果：

```json
{
  "args": {}, 
  "headers": {
    "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8", 
    "Accept-Encoding": "gzip, deflate", 
    "Accept-Language": "zh-CN,en,*", 
    "Connection": "close", 
    "Host": "httpbin.org", 
    "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X) AppleWebKit/538.1 (KHTML, like Gecko) PhantomJS/2.1.0 Safari/538.1"
  }, 
  "origin": "106.185.45.153", 
  "url": "http://httpbin.org/get"
}
```

运行结果的origin同样为代理的IP，设置代理成功。

如果需要认证，那么只需要再加入`--proxy-auth`选项即可，这样参数就改为：

```python
service_args = [
    '--proxy=127.0.0.1:9743',
    '--proxy-type=http',
    '--proxy-auth=username:password'
]
```

将username和password替换为认证所需的用户名和密码即可。

以上便是一些常用库的代理设置方式，本节的源代码地址为[https://github.com/Python3WebSpider/ProxySettings](https://github.com/Python3WebSpider/ProxySettings)








