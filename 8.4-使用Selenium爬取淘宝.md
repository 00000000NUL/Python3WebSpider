# Selenium抓取淘宝商品

在前面我们已经成功尝试分析Ajax来抓取了相关数据，但是并不是所有的页面都是可以分析Ajax来就可以完成抓取的，比如淘宝。它的整个页面数据确实也是通过Ajax获取的，但是这些Ajax接口参数比较复杂，可能会包含加密密钥等参数，所以我们如果想自己构造Ajax参数是比较困难的，对于这种页面我们最方便快捷的抓取方法就是通过Selenium，本节我们就来用Selenium来模拟浏览器操作，抓取淘宝的商品信息，并将结果保存到MongoDB。

## 接口分析

首先我们来看下淘宝的接口，看看它的接口相比一般Ajax多了怎样的内容。

打开淘宝页面，搜索一个商品，比如iPad，此时打开开发者工具，截获Ajax请求，我们可以发现会获取商品列表的接口。

![](./assets/2017-08-06-00-47-29.png)

它的链接包含了几个GET参数，如果我们要想构造Ajax链接直接请求再好不过了，它的返回内容是Json格式。


![](./assets/2017-08-06-00-50-09.jpg)


但是这个Ajax接口包含了几个参数，其中_ksTS、rn参数不能直接发现其规律，如果我们要去探寻它的生成规律也不是做不到，但这样相对会比较繁琐，所以如果我们直接用Selenium来模拟浏览器的话就不需要再关注这些接口参数了，只要在浏览器里面可以看到的我们都可以爬取。这也是为什么我们选用Selenium爬取淘宝的原因。

## 页面分析

我们本节的目标是爬取商品信息，例如：


![](./assets/2017-08-06-00-56-19.jpg)


这样的一个结果就包含了一个商品的基本信息，包括商品图片、名称、价格、购买人数、店铺名称、店铺所在地，我们要做的就是将这些信息都抓取下来。

抓取入口就是淘宝的搜索页面，这个链接是可以直接构造参数访问的，例如如果搜索iPad，就可以直接访问[https://s.taobao.com/search?q=iPad](https://s.taobao.com/search?q=iPad)，呈现的就是第一页的搜索结果，如图所示：


![](./assets/2017-08-06-01-26-45.png)


如果想要分页的话，我们注意到在页面下方有一个分页导航，包括前5页的链接，也包括下一页的链接，同时还有一个输入任意页码跳转的链接，如图所示：


![](./assets/2017-08-06-01-35-44.jpg)

在这里商品搜索结果一般最大都为100页，我们要获取的每一页的内容，只需要将页码从1到100顺次遍历即可，页码数是确定的。所以在这里我们可以直接在页面跳转文本框中输入要跳转的页码，然后点击确定按钮跳转即可到达页码页码对应的页面。

在这里我们不直接点击下一页的原因是，一旦爬取过程中出现异常退出，比如到了50页退出了，我们如果点击下一页就无法快速切换到对应的后续页面，而且爬取过程中我们也需要记录当前的页码数，而且一旦点击下一页之后页面加载失败，我们还需要做异常检测检测当前页面是加载到了第几页，因此整个流程相对复杂，所以在这里我们直接选用跳页的方式来爬取页面。

当我们成功加载出某一页商品列表时，利用Selenium即可获取页面源代码，然后我们再用相应的解析库解析即可，在这里我们选用PyQuery进行解析。

## 代码实战

下面我们用代码来实现一下整个抓取过程。

### 获取商品列表

首先我们需要构造一个抓取的URL，[https://s.taobao.com/search?q=iPad](https://s.taobao.com/search?q=iPad)，URL非常简洁，参数q就是要搜索的关键字，我们只需要改变链接的参数q即可获取不同商品的列表，在这里我们将商品的关键字定义成一个变量，然后构造出这样的一个URL。

构造出URL之后我们就需要用Selenium进行抓取了，我们实现如下抓取列表页的方法：

```python
from selenium import webdriver
from selenium.common.exceptions import TimeoutException
from selenium.webdriver.common.by import By
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.support.wait import WebDriverWait
from urllib.parse import quote

browser = webdriver.Chrome()
wait = WebDriverWait(browser, 10)
KEYWORD = 'iPad'

def index_page(page):
    """
    抓取索引页
    :param page: 页码
    """
    print('正在爬取第', page, '页')
    try:
        url = 'https://s.taobao.com/search?q=' + quote(KEYWORD)
        browser.get(url)
        if page > 1:
            input = wait.until(
                EC.presence_of_element_located((By.CSS_SELECTOR, '#mainsrp-pager div.form > input')))
            submit = wait.until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, '#mainsrp-pager div.form > span.btn.J_Submit')))
            input.clear()
            input.send_keys(page)
            submit.click()
        wait.until(
            EC.text_to_be_present_in_element((By.CSS_SELECTOR, '#mainsrp-pager li.item.active > span'), str(page)))
        wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, '.m-itemlist .items .item')))
        get_products()
    except TimeoutException:
        index_page(page)
```

在这里我们首先构造了一个WebDriver对象，使用的浏览器是Chrome，然后指定一个关键词，如iPad，然后我们定义了一个get_index()方法，用于抓取商品列表页。

在该方法里我们首先访问了这个链接，然后判断了当前的页码，如果大于1，那就进行跳页操作，否则等待页面加载完成。

等待加载我们使用了WebDriverWait对象，它可以指定等待条件，同时指定一个最长等待时间，在这里指定为最长10秒。如果在这个时间内成功匹配了等待条件，也就是说页面元素成功加载出来了，那就立即返回相应结果并继续向下执行，否则到了最大等待时间还没有加载出来就直接抛出超时异常。

比如我们最终要等待商品信息加载出来，在这里就指定了presence_of_element_located这个条件，然后传入了 .m-itemlist .items .item 这个选择器，而这个选择器对应的页面内容就是每个商品的信息块，可以到网页里面查看一下。如果加载成功，就会执行后续的get_products()方法，提取商品信息。

关于翻页的操作，我们在这里是首先获取了页码输入框，赋值为input，然后获取了提交按钮，赋值为submit，分别是下图中的两个元素：

![](./assets/2017-08-06-01-38-14.jpg)

首先我们清空了输入框，调用clear()方法即可，随后调用send_keys()方法将页码填充到输入框中，然后点击确定按钮即可。

那么怎样知道有没有跳转到对应的页码呢？我们可以注意到成功跳转某一页后页码都会高亮显示：

![](./assets/2017-08-06-01-39-44.jpg)

我们只需要判断当前高亮的页码数是当前的页码数即可，所以在这里使用了另一个等待条件 text_to_be_present_in_element，它会等待某一文本出现在某一个节点里面即返回成功，在这里我们将高亮的页码节点对应的CSS选择器和当前要跳转的页码通过参数传递给这个等待条件，这样它就会检测当前高亮的页码节点里是不是我们传过来的页码数，如果是，那就证明页面成功跳转到了这一页，页面跳转成功。

那么这样，刚才我们所实现的get_index()方法就可以做到传入对应的页码，然后加载出对应页码的商品列表后，再去调用get_products()方法进行页面解析。

### 解析商品列表

接下来我们就可以实现get_products()方法来解析商品列表了，在这里我们直接获取页面源代码，然后用PyQuery进行解析，实现如下：

```python
from pyquery import PyQuery as pq
def get_products():
    """
    提取商品数据
    """
    html = browser.page_source
    doc = pq(html)
    items = doc('#mainsrp-itemlist .items .item').items()
    for item in items:
        product = {
            'image': item.find('.pic .img').attr('src'),
            'price': item.find('.price').text(),
            'deal': item.find('.deal-cnt').text(),
            'title': item.find('.title').text(),
            'shop': item.find('.shop').text(),
            'location': item.find('.location').text()
        }
        print(product)
        save_to_mongo(product)
```

首先我们调用了page_source属性获取了页码的源代码，然后构造了PyQuery解析对象，首先我们提取了商品列表，使用的CSS选择器是 #mainsrp-itemlist .items .item，它会匹配到整个页面的每个商品，因此它的匹配结果是多个，所以在这里我们又对它进行了一次遍历，用for循环将每个结果分别进行解析，在这里每个结果我们用for循环把它赋值为item变量，每个item变量都是一个PyQuery对象，然后我们再调用它的find()方法，传入CSS选择器，就可以获取单个商品的特定内容了。

比如在这里我们查看一下商品信息源码，如图所示：

![](./assets/2017-08-06-01-54-05.jpg)

在这里我们观察一下商品图片的源码，它是一个 img 节点，包含了id、class、data-src、alt、src等属性，在这里我们之所以可以看到这张图片是因为它的src属性被赋值为图片的URL，在这里我们就把它的src属性提取出来就可以获取商品的图片了。所以利用find()方法先找到图片的这个节点，然后再调用attr()方法获取商品的src属性即可，这样就成功提取了商品图片链接。然后我们用同样的方法提取商品的价格、成交量、名称、店铺、店铺所在地等信息，然后将所有提取结果赋值为一个字典，叫做product，随后调用save_to_mongo()将其保存到MongoDB即可。

### 保存到MongoDB

接下来我们再将商品信息保存到MongoDB，实现如下：

```python
MONGO_URL = 'localhost'
MONGO_DB = 'taobao'
MONGO_COLLECTION = 'products'
client = pymongo.MongoClient(MONGO_URL)
db = client[MONGO_DB]
def save_to_mongo(result):
    """
    保存至MongoDB
    :param result: 结果
    """
    try:
        if db[MONGO_COLLECTION].insert(result):
            print('存储到MongoDB成功')
    except Exception:
        print('存储到MongoDB失败')
```

我们首先创建了一个MongoDB的连接对象，然后指定了数据库，在方法里随后指定了Collection的名称，然后直接调用insert()方法即可将数据插入到MongoDB，此处的result变量就是在get_products()方法里传来的product，包含了单个商品的信息，这样我们就成功实现了数据的插入。

### 遍历每页

刚才我们所定义的get_index()方法需要接收一个参数page，page即代表页码数，所以在这里我们再实现页码遍历即可，代码如下：

```python
MAX_PAGE = 100
def main():
    """
    遍历每一页
    """
    for i in range(1, MAX_PAGE + 1):
        index_page(i)
```

实现非常简单，只需要调用一个for循环即可，在这里定义最大的页码数100，range()方法的返回结果就是1到100的列表，顺次遍历调用index_page()方法即可。

这样我们的淘宝商品爬虫就完成了，最后调用main()方法即可运行。

## 运行

我们将代码运行起来，可以发现首先会弹出一个Chrome浏览器，然后顺次访问淘宝页面，然后控制台便会输出相应的提取结果，如图所示：


![](./assets/2017-08-06-02-12-00.jpg)

可以发现这些商品信息结果都是一个字典形式，然后被存储到了MongoDB里面。

我们再看一下MongoDB中的结果：


![](./assets/2017-08-06-02-15-07.jpg)

可以看到所有的信息都被保存到MongoDB里了，爬取成功。

## 对接PhantomJS

但是此次爬取有个不太友好的地方就是Chrome浏览器，爬取过程必须要开启一个Chrome浏览器确实不太方便，所以在这里我们还可以对接PhantomJS，只需要将WebDriver的声明修改一下即可，但是注意这里必须要安装好PhantomJS，如果没有安装可以参考第一章里的安装方法说明。

将WebDriver声明修改如下：

```python
browser = webdriver.PhantomJS()
```

这样在抓取过程中就不会有浏览器弹出了。

另外我们还可以设置缓存和禁用图片加载的功能，进一步提高爬取效率，修改如下：

```python
SERVICE_ARGS = ['--load-images=false', '--disk-cache=true']
browser = webdriver.PhantomJS(service_args=SERVICE_ARGS)
```

这样我们就可以禁用PhantomJS的图片加载同时开启缓存，可以发现页面爬取速度进一步提升。

## 源码

本节代码地址为：[https://github.com/Python3WebSpider/TaobaoProduct](https://github.com/Python3WebSpider/TaobaoProduct)。