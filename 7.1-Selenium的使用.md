# 7.1 Selenium的使用

Selenium 是一个自动化测试工具，利用它我们可以驱动浏览器执行特定的动作，如点击、下拉等等操作，同时还可以获取浏览器当前呈现的页面的源代码，做到可见即可爬。对于一些 JavaScript 动态渲染的页面来说，此种抓取方式非常有效，本节让我们来感受一下它的强大之处吧。

### 1. 准备工作

本节以 Chrome 为例来讲解 Selenium 的用法，在本节开始之前请确保已经正确安装好了 Chrome 浏览器并配置好了 ChromeDriver，另外还需要正确安装好 Python 的 Selenium 库，详细的过程可以参考第一章的安装和配置说明。

### 2. 基本使用

准备工作做好之后，首先我们来大体看一下 Selenium 有一些怎样的功能，先用一段实例代码来感受一下：

```python
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.support.wait import WebDriverWait

browser = webdriver.Chrome()
try:
    browser.get('https://www.baidu.com')
    input = browser.find_element_by_id('kw')
    input.send_keys('Python')
    input.send_keys(Keys.ENTER)
    wait = WebDriverWait(browser, 10)
    wait.until(EC.presence_of_element_located((By.ID, 'content_left')))
    print(browser.current_url)
    print(browser.get_cookies())
    print(browser.page_source)
finally:
    browser.close()
```

运行代码之后可以发现会自动弹出一个 Chrome 浏览器，浏览器首先会跳转到百度，然后在搜索框中输入 Python 进行搜索，然后跳转到搜索结果页，等待搜索结果加载出来之后，控制台分别会输出当前的 URL，当前的 Cookies 还有网页源代码，如图所示：

![](./assets/2017-05-26-18-14-46.png)

此时在控制台的输出结果如下：

```
https://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=0&rsv_idx=1&tn=baidu&wd=Python&rsv_pq=c94d0df9000a72d0&rsv_t=07099xvun1ZmC0bf6eQvygJ43IUTTUOl5FCJVPgwG2YREs70GplJjH2F%2BCQ&rqlang=cn&rsv_enter=1&rsv_sug3=6&rsv_sug2=0&inputT=87&rsv_sug4=87
[{'secure': False, 'value': 'B490B5EBF6F3CD402E515D22BCDA1598', 'domain': '.baidu.com', 'path': '/', 'httpOnly': False, 'name': 'BDORZ', 'expiry': 1491688071.707553}, {'secure': False, 'value': '22473_1441_21084_17001', 'domain': '.baidu.com', 'path': '/', 'httpOnly': False, 'name': 'H_PS_PSSID'}, {'secure': False, 'value': '12883875381399993259_00_0_I_R_2_0303_C02F_N_I_I_0', 'domain': '.www.baidu.com', 'path': '/', 'httpOnly': False, 'name': '__bsi', 'expiry': 1491601676.69722}]
<!DOCTYPE html><!--STATUS OK-->...</html>
```

源代码过长在此省略，可以看到我们得到的当前的 URL、Cookies、源代码都是浏览器中的真实内容。

所以说，如果我们用 Selenium 来驱动浏览器加载网页的话，我们就可以直接拿到 JavaScript 渲染的结果了，不管是什么加密统统不用再需要担心。

下面我们来详细了解一下Selenium的用法。

### 3. 声明浏览器对象

Selenium 支持非常多的浏览器，如 Chrome、Firefox、Edge 等，还有手机端的浏览器 Android、BlackBerry 等，另外无界面浏览器 PhantomJS 也同样支持。

我们可以用如下的方式初始化：

```python
from selenium import webdriver

browser = webdriver.Chrome()
browser = webdriver.Firefox()
browser = webdriver.Edge()
browser = webdriver.PhantomJS()
browser = webdriver.Safari()
```

这样我们就完成了浏览器对象的初始化并赋值为 browser 对象，接下来我们要做的就是调用 browser 对象，让其执行各个动作，就可以模拟浏览器操作了。

### 3. 访问页面

我们可以用 get() 方法来请求一个网页，参数传入链接 URL 即可，比如在这里我们用 get() 方法访问淘宝，然后打印出源代码，代码如下：

```python
from selenium import webdriver

browser = webdriver.Chrome()
browser.get('https://www.taobao.com')
print(browser.page_source)
browser.close()
```

运行之后我们便发现弹出了 Chrome 浏览器，自动访问了淘宝，然后控制台输出了淘宝页面的源代码，随后浏览器关闭。

通过这几行简单的代码我们便可以实现浏览器的驱动并获取网页源码，非常便捷。

### 4. 查找节点

Selenium 可以驱动浏览器完成各种操作，比如填充表单、模拟点击等等，比如我们想要完成向某个输入框输入文字的操作，总得需要知道这个输入框在哪里吧？所以 Selenium 提供了一系列查找节点的方法，我们可以用这些方法来获取想要的节点，以便于下一步执行一些动作或者提取信息。

#### 单个节点

比如我们想要从淘宝页面中提取搜索框这个节点，首先观察它的源代码：

![](./assets/2017-05-26-21-04-05.png)

可以发现它的 ID 是 q，Name 也是 q，还有许多其他属性，那我们获取它的方式就有多种形式了，比如find_element_by_name() 是根据 Name 值获取，ind_element_by_id() 是根据 ID 获取，另外还有根据XPath、CSS Selector 等获取的方式。

我们用代码实现一下：

```python
from selenium import webdriver

browser = webdriver.Chrome()
browser.get('https://www.taobao.com')
input_first = browser.find_element_by_id('q')
input_second = browser.find_element_by_css_selector('#q')
input_third = browser.find_element_by_xpath('//*[@id="q"]')
print(input_first, input_second, input_third)
browser.close()
```

在这里我们使用了三种方式获取输入框，根据 ID、CSS Selector 和 XPath 获取，它们返回的结果是完全一致的。

运行结果：

```python
<selenium.webdriver.remote.webelement.WebElement (session="5e53d9e1c8646e44c14c1c2880d424af", element="0.5649563096161541-1")> 
<selenium.webdriver.remote.webelement.WebElement (session="5e53d9e1c8646e44c14c1c2880d424af", element="0.5649563096161541-1")> 
<selenium.webdriver.remote.webelement.WebElement (session="5e53d9e1c8646e44c14c1c2880d424af", element="0.5649563096161541-1")>
```

可以看到三个节点都是 WebElement 类型，是完全一致的。

在这里列出所有获取单个节点的方法：

```
find_element_by_id
find_element_by_name
find_element_by_xpath
find_element_by_link_text
find_element_by_partial_link_text
find_element_by_tag_name
find_element_by_class_name
find_element_by_css_selector
```

另外 Selenium 还提供了通用的 find_element() 方法，它需要传入两个参数，一个是查找的方式 By，另一个就是值，实际上它就是 find_element_by_id() 这种方法的通用函数版本，比如 find_element_by_id(id) 就等价于 find_element(By.ID, id)，二者得到的结果完全一致。

我们用代码实现一下：

```python
from selenium import webdriver
from selenium.webdriver.common.by import By

browser = webdriver.Chrome()
browser.get('https://www.taobao.com')
input_first = browser.find_element(By.ID, 'q')
print(input_first)
browser.close()
```

这样的查找方式实际上功能和上面列举的查找函数完全一致，不过参数更加灵活。

#### 多个节点

如果我们查找的目标在网页中只有一个，那么完全可以用 find_element() 方法，但如果有多个节点，再用 find_element() 方法查找就只能得到第一个节点了，如果要查找所有满足条件的节点，那就需要用 find_elements() 这样的方法，方法名称中 element 多了一个 s ，注意区分。

比如我们在这里查找淘宝左侧导航条的所有条目：

![](./assets/2017-08-22-02-40-11.jpg)

就可以这样来实现：

```python
from selenium import webdriver

browser = webdriver.Chrome()
browser.get('https://www.taobao.com')
lis = browser.find_elements_by_css_selector('.service-bd li')
print(lis)
browser.close()
```

运行结果：

```
[<selenium.webdriver.remote.webelement.WebElement (session="c26290835d4457ebf7d96bfab3740d19", element="0.09221044033125603-1")>, <selenium.webdriver.remote.webelement.WebElement (session="c26290835d4457ebf7d96bfab3740d19", element="0.09221044033125603-2")>, <selenium.webdriver.remote.webelement.WebElement (session="c26290835d4457ebf7d96bfab3740d19", element="0.09221044033125603-3")>...<selenium.webdriver.remote.webelement.WebElement (session="c26290835d4457ebf7d96bfab3740d19", element="0.09221044033125603-16")>]
```

在此简化了一下输出结果，中间部分省略。

可以看到得到的内容就变成了列表类型，列表的每个节点都是 WebElement 类型。

也就是说，如果我们用 find_element() 方法，只能获取匹配的第一个节点，结果是 WebElement 类型，如果用 find_elements() 方法，则结果是列表类型，列表的每个节点是 WebElement 类型。

函数的列表如下：

```
find_elements_by_id
find_elements_by_name
find_elements_by_xpath
find_elements_by_link_text
find_elements_by_partial_link_text
find_elements_by_tag_name
find_elements_by_class_name
find_elements_by_css_selector
```

当然我们和刚才一样，也可可以直接 find_elements() 方法来选择，所以也可以这样来写：

```python
lis = browser.find_elements(By.CSS_SELECTOR, '.service-bd li')
```

结果是完全一致的。

### 5. 节点交互

Selenium 可以驱动浏览器来执行一些操作，也就是说我们可以让浏览器模拟执行一些动作，比较常见的用法有：

输入文字用 send_keys() 方法，清空文字用 clear() 方法，另外还有按钮点击，用 click() 方法。

我们用一个实例来感受一下：

```python
from selenium import webdriver
import time

browser = webdriver.Chrome()
browser.get('https://www.taobao.com')
input = browser.find_element_by_id('q')
input.send_keys('iPhone')
time.sleep(1)
input.clear()
input.send_keys('iPad')
button = browser.find_element_by_class_name('btn-search')
button.click()
```

在这里我们首先驱动浏览器打开淘宝，然后用 find_element_by_id() 方法获取输入框，然后用 send_keys() 方法输入 iPhone 文字，等待一秒之后用 clear() 方法清空输入框，再次调用 send_keys() 方法输入 iPad 文字，之后再用 find_element_by_class_name() 方法获取搜索按钮，最后调用 click() 方法完成搜索动作。

通过上面的方法我们就完成了一些常见节点的动作操作，更多的操作可以参见官方文档的交互动作介绍：[http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.remote.webelement](http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.remote.webelement)。

### 6. 动作链

在上面的实例中，一些交互动作都是针对某个节点执行的，比如输入框我们就调用它的输入文字和清空文字方法，按钮就调用它的点击方法，其实还有另外的一些操作它是没有特定的执行对象的，比如鼠标拖拽、键盘按键等操作。所以这些动作我们有另一种方式来执行，那就是动作链。

比如我们现在实现一个节点的拖拽操作，将某个节点从一处拖拽到另外一处，可以用代码这样实现：

```python
from selenium import webdriver
from selenium.webdriver import ActionChains

browser = webdriver.Chrome()
url = 'http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable'
browser.get(url)
browser.switch_to.frame('iframeResult')
source = browser.find_element_by_css_selector('#draggable')
target = browser.find_element_by_css_selector('#droppable')
actions = ActionChains(browser)
actions.drag_and_drop(source, target)
actions.perform()
```

首先我们打开网页中的一个拖拽实例，然后依次选中要被拖拽的节点和拖拽到的目标节点，然后声明了 ActionChains 对象赋值为 actions 变量，然后通过调用 actions 变量的 drag_and_drop() 方法，然后再调用 perform() 方法执行动作，就完成了拖拽操作，如图所示：

![](./assets/2017-05-26-21-01-45.jpg)

![](./assets/2017-05-26-21-02-10.jpg)

以上两图分别为在拖拽前和拖拽后的结果。

更多的动作链操作可以参考官方文档的动作链介绍：[http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.common.action_chains](http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.common.action_chains)。

### 7. 执行JavaScript

对于某些操作，Selenium API 是没有提供的，如下拉进度条等，可以直接模拟运行 JavaScript，使用 execute_script() 方法即可实现，代码如下：

```python
from selenium import webdriver

browser = webdriver.Chrome()
browser.get('https://www.zhihu.com/explore')
browser.execute_script('window.scrollTo(0, document.body.scrollHeight)')
browser.execute_script('alert("To Bottom")')
```

在这里我们就利用了 execute_script() 方法将进度条下拉到最底部，然后弹出 alert 提示框。

所以说有了这个，基本上 API 没有提供的所有的功能都可以用执行 JavaScript 的方式来实现了。

### 8. 获取节点信息

我们在前面说过通过 page_source 属性可以获取网页的源代码，获取源代码之后就可以使用解析库如正则、BeautifulSoup、PyQuery 等来提取信息了。

不过既然 Selenium 已经提供了选择节点的方法，返回的是WebElement 类型，那么它也有相关的方法和属性来直接提取节点信息，如属性、文本等等。这样的话我们就可以不用通过解析源代码来提取信息了，非常方便。

那接下来我们就看一下可以通过怎样的方式来获取节点信息吧。

#### 获取属性

我们可以使用 get_attribute() 方法来获取节点的属性，那么这个的前提就是先选中这个节点。

我们用一个实例来感受一下：

```python
from selenium import webdriver
from selenium.webdriver import ActionChains

browser = webdriver.Chrome()
url = 'https://www.zhihu.com/explore'
browser.get(url)
logo = browser.find_element_by_id('zh-top-link-logo')
print(logo)
print(logo.get_attribute('class'))
```

运行之后程序便会驱动浏览器打开知乎的页面，然后获取知乎的 LOGO 节点，然后将它的 class 打印出来。

控制台输出结果：

```python
<selenium.webdriver.remote.webelement.WebElement (session="e08c0f28d7f44d75ccd50df6bb676104", element="0.7236390660048155-1")>
zu-top-link-logo
```

我们通过 get_attribute() 方法，然后传入想要获取的属性名，就可以得到它的值了。

#### 获取文本值

每个 WebEelement 节点都有 text 属性，我们可以通过直接调用这个属性就可以得到节点内部的文本信息了，就相当于 BeautifulSoup 的 get_text() 方法、PyQuery 的 text() 方法。

我们用一个实例来感受一下：

```python
from selenium import webdriver

browser = webdriver.Chrome()
url = 'https://www.zhihu.com/explore'
browser.get(url)
input = browser.find_element_by_class_name('zu-top-add-question')
print(input.text)
```

在这里们依然是先打开知乎页面，然后获取提问按钮这个节点，再将其文本值打印出来。

控制台输出结果：

```
提问
```

#### 获取ID、位置、标签名、大小

另外 WebElement 节点还有一些其他的属性，比如 id 属性可以获取节点 id，location 可以获取该节点在页面中的相对位置，tag_name 可以获取标签名称，size 可以获取节点的大小，也就是宽高，这些属性有时候还是很有用的。

我们用实例来感受一下：

 ```python
 from selenium import webdriver

browser = webdriver.Chrome()
url = 'https://www.zhihu.com/explore'
browser.get(url)
input = browser.find_element_by_class_name('zu-top-add-question')
print(input.id)
print(input.location)
print(input.tag_name)
print(input.size)
 ```

在这里我们首先获得了提问按钮这个节点，然后调用其 id、location、tag_name、size 属性即可获取对应的属性值。

### 9. 切换Frame

我们知道在网页中有这样一种节点叫做 iframe，也就是子Frame，相当于页面的子页面，它的结构和外部网页的结构是完全一致的。Selenium 打开页面后，它默认是在父级Frame 里面操作，而此时如果页面中还有子 Frame，它是不能获取到子 Frame 里面的节点的。所以这时候我们就需要使用 switch_to.frame() 方法来切换 Frame。

我们首先用一个实例来感受一下：

```python
import time
from selenium import webdriver
from selenium.common.exceptions import NoSuchElementException

browser = webdriver.Chrome()
url = 'http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable'
browser.get(url)
browser.switch_to.frame('iframeResult')
try:
    logo = browser.find_element_by_class_name('logo')
except NoSuchElementException:
    print('NO LOGO')
browser.switch_to.parent_frame()
logo = browser.find_element_by_class_name('logo')
print(logo)
print(logo.text)
```

控制台输出：

```python
NO LOGO
<selenium.webdriver.remote.webelement.WebElement (session="4bb8ac03ced4ecbdefef03ffdc0e4ccd", element="0.13792611320464965-2")>
RUNOOB.COM
```

我们还是以上文演示动作链操作的网页为实例，首先我们通过 switch_to.frame() 方法切换到子 Frame 里面，然后我们尝试获取父级 Frame 里的 LOGO 节点，是不能找到的，找不到的话就会抛出 NoSuchElementException 异常，异常被捕捉之后就会输出 NO LOGO，接下来我们重新切换回父Frame，然后再次重新获取节点，发现就可以成功获取了。

所以，当页面中包含子 Frame 时，如果我们想获取子Frame 中的节点，需要先调用 switch_to.frame() 方法切换到对应的 Frame，然后再进行操作即可。

### 10. 延时等待

在 Selenium 中，get() 方法会在网页框架加载结束之后就结束执行，此时如果获取 page_source 可能并不是浏览器完全加载完成的页面，如果某些页面有额外的 Ajax 请求，我们在网页源代码中也不一定能成功获取到。所以这里我们需要延时等待一定时间确保节点已经加载出来。

在这里等待的方式有两种，一种隐式等待，一种显式等待。

#### 隐式等待

当使用了隐式等待执行测试的时候，如果 Selenium 没有在DOM 中找到节点，将继续等待，超出设定时间后则抛出找不到节点的异常, 换句话说，当查找节点而节点并没有立即出现的时候，隐式等待将等待一段时间再查找 DOM，默认的时间是 0。

我们用一个实例来感受一下：

```python
from selenium import webdriver

browser = webdriver.Chrome()
browser.implicitly_wait(10)
browser.get('https://www.zhihu.com/explore')
input = browser.find_element_by_class_name('zu-top-add-question')
print(input)
```

在这里我们用 implicitly_wait() 方法实现了隐式等待。

#### 显式等待

隐式等待的效果其实并没有那么好，因为我们只是规定了一个固定时间，而页面的加载时间是受到网络条件影响的。

所以在这里还有一种更合适的显式等待方法，它指定好要查找的节点，然后指定一个最长等待时间。如果在规定时间内加载出来了这个节点，那就返回查找的节点，如果到了规定时间依然没有加载出该节点，则会抛出超时异常。

我们用一个实例来感受一下：

```python
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

browser = webdriver.Chrome()
browser.get('https://www.taobao.com/')
wait = WebDriverWait(browser, 10)
input = wait.until(EC.presence_of_element_located((By.ID, 'q')))
button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, '.btn-search')))
print(input, button)
```

在这里我们首先引入了 WebDriverWait 这个对象，指定好最长等待时间，然后调用它的 until() 方法，传入要等待条件 expected_conditions，比如在这里我们传入了 presence_of_element_located 这个条件，就代表节点出现的意思，其参数是节点的定位元组，也就是 ID 为 q 的节点搜索框。

所以这样可以做到的效果就是，在 10 秒内如果 ID 为 q 的节点即搜索框成功加载出来了，那就返回该节点，如果超过10 秒还没有加载出来，那就抛出异常。

对于按钮，可以更改一下等待条件，比如改为 element_to_be_clickable，也就是可点击，所以查找按钮时是查找 CSS 选择器为 .btn-search 的按钮，如果 10 秒内它是可点击的也就是成功加载出来了，那就返回这个按钮节点，如果超过 10 秒还不可点击，也就是没有加载出来，那就抛出异常。

运行代码，在网速较佳的情况下是可以成功加载出来的。

控制台输出：

```python
<selenium.webdriver.remote.webelement.WebElement (session="07dd2fbc2d5b1ce40e82b9754aba8fa8", element="0.5642646294074107-1")>
<selenium.webdriver.remote.webelement.WebElement (session="07dd2fbc2d5b1ce40e82b9754aba8fa8", element="0.5642646294074107-2")>
```

可以看到控制台成功输出了两个节点，都是 WebElement 类型。

如果网络有问题，10 秒内没有成功加载，那就抛出TimeoutException，控制台输出如下：

```python
TimeoutException Traceback (most recent call last)
<ipython-input-4-f3d73973b223> in <module>()
      7 browser.get('https://www.taobao.com/')
      8 wait = WebDriverWait(browser, 10)
----> 9 input = wait.until(EC.presence_of_element_located((By.ID, 'q')))
```

关于等待条件，其实还有很多，比如判断标题内容，判断某个节点内是否出现了某文字，在这里将所有的加载条件列举如下：

| 等待条件 | 含义 |
| ------ | ---- | 
| title_is | 标题是某内容 |
| title_contains | 标题包含某内容 |
| presence_of_element_located | 节点加载出，传入定位元组，如(By.ID, 'p') |
| visibility_of_element_located | 节点可见，传入定位元组 |
| visibility_of | 可见，传入节点对象 |
| presence_of_all_elements_located | 所有节点加载出 |
| text_to_be_present_in_element | 某个节点文本包含某文字 |
| text_to_be_present_in_element_value | 某个节点值包含某文字 |
| frame_to_be_available_and_switch_to_it frame | 加载并切换 |
| invisibility_of_element_located | 节点不可见 |
| element_to_be_clickable | 节点可点击 |
| staleness_of | 判断一个节点是否仍在DOM，可判断页面是否已经刷新 |
| element_to_be_selected | 节点可选择，传节点对象 |
| element_located_to_be_selected | 节点可选择，传入定位元组 |
| element_selection_state_to_be | 传入节点对象以及状态，相等返回True，否则返回False |
| element_located_selection_state_to_be | 传入定位元组以及状态，相等返回True，否则返回False |
| alert_is_present | 是否出现Alert |

更多详细的等待条件的参数及用法介绍可以参考官方文档：[http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.support.expected_conditions](http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.support.expected_conditions)。

### 11. 前进后退

我们平常使用浏览器都有前进和后退功能，使用 Selenium 也可以完成这个操作，使用 back() 方法可以后退，forward() 方法可以前进。

我们用一个实例来感受一下：

```python
import time
from selenium import webdriver

browser = webdriver.Chrome()
browser.get('https://www.baidu.com/')
browser.get('https://www.taobao.com/')
browser.get('https://www.python.org/')
browser.back()
time.sleep(1)
browser.forward()
browser.close()
```

在这里我们连续访问三个页面，然后调用 back() 方法就可以回到第二个页面，接下来再调用 forward() 方法又可以前进到第三个页面。

### 12. Cookies

使用 Selenium 还可以方便地对 Cookies 进行操作，例如获取、添加、删除 Cookies 等等。

 我们再用实例来感受一下：

```python
from selenium import webdriver

browser = webdriver.Chrome()
browser.get('https://www.zhihu.com/explore')
print(browser.get_cookies())
browser.add_cookie({'name': 'name', 'domain': 'www.zhihu.com', 'value': 'germey'})
print(browser.get_cookies())
browser.delete_all_cookies()
print(browser.get_cookies())
```

首先我们访问了知乎，然后加载完成之后，浏览器实际上已经生成了 Cookies 了，我们调用 get_cookies() 方法就可以获取所有的 Cookies，然后我们添加一个 Cookie，传入一个字典，有 name、domain、value 等内容。接下来我们再次获取所有的 Cookies，可以发现结果就多了这一项 Cookie。最后我们调用 delete_all_cookies() 方法，删除所有的 Cookies，再重新获取，结果就为空了。

控制台输出：

```python
[{'secure': False, 'value': '"NGM0ZTM5NDAwMWEyNDQwNDk5ODlkZWY3OTkxY2I0NDY=|1491604091|236e34290a6f407bfbb517888849ea509ac366d0"', 'domain': '.zhihu.com', 'path': '/', 'httpOnly': False, 'name': 'l_cap_id', 'expiry': 1494196091.403418}]
[{'secure': False, 'value': 'germey', 'domain': '.www.zhihu.com', 'path': '/', 'httpOnly': False, 'name': 'name'}, {'secure': False, 'value': '"NGM0ZTM5NDAwMWEyNDQwNDk5ODlkZWY3OTkxY2I0NDY=|1491604091|236e34290a6f407bfbb517888849ea509ac366d0"', 'domain': '.zhihu.com', 'path': '/', 'httpOnly': False, 'name': 'l_cap_id', 'expiry': 1494196091.403418}]
[]
```

通过以上方法来操作 Cookies 还是非常方便的。

### 13. 选项卡管理

我们在访问网页的时候会开启一个个选项卡，那么在 Selenium 中也可以对选项卡进行操作。

```python
import time
from selenium import webdriver

browser = webdriver.Chrome()
browser.get('https://www.baidu.com')
browser.execute_script('window.open()')
print(browser.window_handles)
browser.switch_to_window(browser.window_handles[1])
browser.get('https://www.taobao.com')
time.sleep(1)
browser.switch_to_window(browser.window_handles[0])
browser.get('https://python.org')
```

控制台输出：

```
['CDwindow-4f58e3a7-7167-4587-bedf-9cd8c867f435', 'CDwindow-6e05f076-6d77-453a-a36c-32baacc447df']
```

首先我们访问了百度，然后调用了 execute_script() 方法，传入 window.open() 的 JavaScript 语句新开启一个选项卡，然后接下来我们想切换到该选项卡，可以调用 window_handles 属性获取当前开启的所有选项卡，返回的是选项卡的代号列表，要想切换选项卡只需要调用 switch_to_window() 方法，传入选项卡的代号即可。在这里我们将第二个选项卡代号传入，即跳转到了第二个选项卡，然后接下来在第二个选项卡下打开一个新的页面，然后切换回第一个选项卡可以重新调用 switch_to_window() 方法，再执行其他操作即可。

如此以来我们便实现了选项卡的管理。

### 14. 异常处理

在使用 Selenium 过程中，难免会遇到一些异常，例如超时、节点未找到等错误，一旦出现此类错误，程序便不会继续运行了，所以异常处理在程序中是十分重要的。

在这里我们可以使用 try except 语句来捕获各种异常。

首先我们演示一下节点未找到的异常，示例如下：

```python
from selenium import webdriver

browser = webdriver.Chrome()
browser.get('https://www.baidu.com')
browser.find_element_by_id('hello')
```

在这里我们打开百度页面，然后尝试选择一个并不存在的节点，这样就会遇到异常。

运行之后控制台输出如下：

```python
NoSuchElementException Traceback (most recent call last)
<ipython-input-23-978945848a1b> in <module>()
      3 browser = webdriver.Chrome()
      4 browser.get('https://www.baidu.com')
----> 5 browser.find_element_by_id('hello')
```

可以看到抛出了 NoSuchElementException 这类异常，这通常是节点未找到的异常，为了防止程序遇到异常而中断，我们需要捕获一下这些异常。

```python
from selenium import webdriver
from selenium.common.exceptions import TimeoutException, NoSuchElementException

browser = webdriver.Chrome()
try:
    browser.get('https://www.baidu.com')
except TimeoutException:
    print('Time Out')
try:
    browser.find_element_by_id('hello')
except NoSuchElementException:
    print('No Element')
finally:
    browser.close()
```

如上例所示，这里我们使用 try except 来捕获各类异常，比如我们对 find_element_by_id() 查找节点的方法捕获 NoSuchElementException 异常，这样一旦出现这样的错误，就进行异常处理，程序也不会中断了。

控制台输出：

```python
No Element
```

更多的异常累可以参考官方文档：[http://selenium-python.readthedocs.io/api.html#module-selenium.common.exceptions](http://selenium-python.readthedocs.io/api.html#module-selenium.common.exceptions)，如果出现了某个异常，我们对它进行捕获即可。

### 15. 结语

到此我们就基本对 Selenium 的常用用法有了大体的了解，有了 Selenium，处理 JavaScript 不再是难事。