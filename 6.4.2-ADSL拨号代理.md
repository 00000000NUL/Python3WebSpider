# ADSL拨号代理服务器

我们尝试维护过一个免费的代理池，但是代理池效果用过就知道了，毕竟里面有大量免费代理，虽然这些代理是可用的，但是既然我们能刷到这个免费代理，别人也能呀，所以就导致这个代理同时被很多人使用来抓取网站，所以当我们兴致勃勃地拿他来抓取某个网站的时候，会发现它还是被网站封禁的状态，所以在某些情况下免费代理池的成功率还是比较低的。

当然我们也可以去购买一些代理，比如几块钱提取几百几千个的代理，然而经过测试后质量也是很一般，也可以去购买专线代理，不过价格也是不菲的。那么目前最稳定而且又保证可用的代理方法就是设置ADSL拨号代理了。

本篇来讲解一下ADSL拨号代理服务器的相关设置。

## 什么是ADSL

大家可能对ADSL比较陌生，ADSL全称叫做Asymmetric Digital Subscriber Line，非对称数字用户环路，因为它的上行和下行带宽不对称。它采用频分复用技术把普通的电话线分成了电话、上行和下行三个相对独立的信道，从而避免了相互之间的干扰。

有种主机叫做动态拨号VPS主机，这种主机在连接上网的时候是需要拨号的，只有拨号成功后才可以上网，每拨一次号，主机就会获取一个新的IP，也就是它的IP并不是固定的，而且IP量特别大，几乎不会拨到相同的IP，如果我们用它来搭建代理，既能保证高度可用，又可以自由控制拨号切换。

经测试发现这也是最稳定最有效的代理方式，本节详细介绍一下ADSL拨号代理服务器的搭建方法。

## 购买动态拨号VPS主机

所以在开始之前，我们需要先购买一台动态拨号VPS主机，这样的主机在百度搜索一下，服务商还是相当多的，在这里推荐一家[云立方](http://www.yunlifang.cn/dynamicvps.asp)，感觉还是比较良心的，非广告。

配置的话可以自行选择，看下带宽是否可以满足需求就好了。

购买完成之后，就需要安装操作系统了，进入拨号主机的后台，首先预装一个操作系统。

![](./assets/2017-05-19-14-01-39.jpg)

在这里推荐安装CentOS7系统。

然后找到远程管理面板找到远程连接的用户名和密码，也就是SSH远程连接服务器的信息。

比如我这边的IP端口分别是 153.36.65.214:20063，用户名是root。

命令行下输入：

```
ssh root@153.36.65.214 -p 20063
```

然后输入管理密码，就可以连接上远程服务器了。

进入之后，可以发现有一个可用的脚本文件，叫做ppp.sh，这是拨号初始化的脚本，运行它会让我们输入拨号的用户名和密码，然后它就会开始各种拨号配置，一次配置成功，后面的拨号就不需要重复输入用户名和密码了。

运行ppp.sh脚本，输入用户名密码等待它的配置完成。


![](./assets/2017-05-19-14-09-39.jpg)


都提示成功之后就可以进行拨号了。

在拨号之前如果我们测试ping任何网站都是不通的，因为当前网络还没联通，输入拨号命令：

```
adsl-start
```

可以发现拨号命令成功运行，没有任何报错信息，这就证明拨号成功完成了，耗时约几秒钟。接下来如果再去ping外网就可以通了。

如果要停止拨号可以输入：

```
adsl-stop
```

停止之后，可以发现又连不通网络了。

所以只有拨号之后才可以建立网络连接。


![](./assets/2017-05-19-14-08-35.jpg)


所以断线重播的命令就是二者组合起来，先执行`adsl-stop`再执行`adsl-start`，每拨一次号，`ifocnfig`命令观察一下主机的IP，发现主机的IP一直是在变化的，网卡名称叫做ppp0。


![](./assets/2017-05-19-14-10-47.jpg)


所以，到这里我们就可以知道它作为代理服务器的巨大优势了，如果将这台主机作为代理服务器，如果我们一直拨号换IP，就不怕遇到IP被封的情况了，即使某个IP被封了，重新拨一次号就好了。

所以接下来我们要做的就有两件事，一是怎样将主机设置为代理服务器，二是怎样实时获取拨号主机的IP。

## 设置代理服务器

之前我们经常听说代理服务器，也设置过不少代理了，但是可能没有自己设置吧，自己有一台主机怎样设置为代理服务器呢？接下来我们就亲自试验下怎样搭建HTTP代理服务器。

在Linux下搭建HTTP代理服务器，推荐TinyProxy和Squid，配置都非常简单，在这里我们以TinyProxy为例来讲解一下怎样搭建代理服务器。

### 安装TinyProxy

当然第一步就是安装TinyProxy这个软件了，在这里我使用的系统是CentOS，所以使用yum来安装，如果是其他系统如Ubuntu可以选择apt-get等命令安装，都是类似的。

命令行执行yum安装指令：

```
yum install -y epel-release
yum update -y
yum install -y tinyproxy
```

运行完成之后就可以完成tinyproxy的安装了。

### 配置TinyProxy

安装完成之后还需要配置一下TinyProxy才可以用作代理服务器，需要编辑配置文件，它一般的路径是`/etc/tinyproxy/tinyproxy.conf`。

可以看到有一行

```
Port 8888
```

在这里可以设置代理的端口，默认是8888。

然后继续向下找，有这么一行

```
Allow 127.0.0.1
```

这是被允许连接的主机的IP，如果想任何主机都可以连接，那就直接将它注释即可，所以在这里我们选择直接注释，也就是任何主机都可以使用这台主机作为代理服务器了。

修改为

```
# Allow 127.0.0.1
```

设置完成之后重启TinyProxy即可。

```
systemctl enable tinyproxy.service
systemctl restart  tinyproxy.service
```

防火墙开放该端口

```
iptables -I INPUT -p tcp --dport 8888 -j ACCEPT
```

当然如果想直接关闭防火墙也可以

```
systemctl stop firewalld.service
```


### 验证TinyProxy

好了，这样我们就成功搭建好代理服务器了，首先`ifconfig`查看下当前主机的IP，比如当前我的主机拨号IP为`112.84.118.216`，在其他的主机运行测试一下。

比如用curl命令设置代理请求一下httpbin，检测下代理是否生效。

```
curl -x 112.84.118.216:8888 httpbin.org/get
```

![](./assets/2017-05-19-14-19-11.jpg)


如果有正常的结果输出并且origin的值为代理IP的地址，就证明TinyProxy配置成功了。

好，那到现在，我们接下来要做的就是需要动态实时获取主机的IP了。

## 动态获取IP

真正的好戏才开始呢，我们怎样动态获取主机的IP呢？可能你首先想到的是DDNS也就是动态域名解析服务，我们需要使用一个域名来解析，也就是虽然IP是变的，但域名解析的地址可以随着IP的变化而变化。

它的原理其实是拨号主机向固定的服务器发出请求，服务器获取客户端的IP，然后再将域名解析到这个IP上就可以了。

国内比较有名的服务就是[花生壳](http://hsk.oray.com/)了，也提供了免费版的动态域名解析，另外DNSPOD也提供了解析接口来动态修改域名解析设置，[DNSPOD](https://www.dnspod.cn/docs/records.html#dns)，但是这样的方式都有一个通病，那就是慢！

原因在于DNS修改后到完全生效是需要一定时间的，所以如果在前一秒拨号了，这一秒的域名解析的可能还是原来的IP，时间长的话可能需要几分钟，也就是说这段时间内，服务器IP已经变了，但是域名还是上一次拨号的IP，所以代理是不能用的，对于爬虫这种秒级响应的需求，是完全不能接受的。

所以根据花生壳的原理，可以完全自己实现一下动态获取IP的方法。

所以本节重点介绍的就是怎样来实现实时获取拨号主机IP的方法。

要实现这个需要两台主机，一台主机就是这台动态拨号VPS主机，另一台是具有固定公网IP的主机。动态VPS主机拨号成功之后就请求远程的固定主机，远程主机获取动态VPS主机的IP，就可以得到这个代理，将代理保存下来，这样拨号主机每拨号一次，远程主机就会及时得到拨号主机的IP，如果有多台拨号VPS，也统一发送到远程主机，这样我们只需要从远程主机取下代理就好了，保准是实时可用，稳定高效的。

整体思路大体是这样子，当然为了更完善一下，我们要做到如下功能：

远程主机：

* 监听主机请求，获取动态VPS主机IP
* 将VPS主机IP记录下来存入数据库，支持多个客户端
* 检测当前接收到的IP可用情况，如果不可用则删除
* 提供API接口，通过API接口可获取当前可用代理IP

拨号VPS：

* 定时执行拨号脚本换IP
* 换IP后立即请求远程主机
* 拨号后检测是否拨号成功，如果失败立即重新拨号

### 远程主机实现

说了这么多，那么我们就梳理一下具体的实现吧，整个项目我们用Python3实现。

#### 数据库

远程主机作为一台服务器，动态拨号VPS会定时请求远程主机，远程主机接收到请求后将IP记录下来存入数据库。
因为IP是一直在变化的，IP更新了之后，原来的IP就不能用了，所以对于一个主机来说我们可能需要多次更新一条数据。另外我们不能仅限于维护一台拨号VPS主机，当然是需要支持多台维护的。在这里我们直接选用Key-Value形式的非关系型数据库存储更加方便，所以在此选用Redis数据库。

既然是Key-Value，Key是什么?Value是什么?首先我们能确定Value就是代理的值，比如112.84.119.67:8888，那么Key是什么？我们知道，这个IP是针对一台动态拨号VPS的，而且这个值会不断地变，所以我们需要有一个不变量Key来唯一标识这台主机，所以在这里我们可以把Key当做主机名称。名称怎么来？自己取就好了，只要每台主机的名字不重复，我们就可以区分出是哪台主机了，这个名字可以在拨号主机那边指定，然后传给远程主机就好了。

所以，在这里数据库我们选用Redis，Key就是拨号主机的名称，可以自己指定，Value就是代理的值。

所以可以写一个操作Redis数据库的类，参考如下：

```python
class RedisClient(object):
    def __init__(self, host=REDIS_HOST, port=REDIS_PORT):
        self.db = redis.Redis(host=host, port=port, password=REDIS_PASSWORD)
        self.proxy_key = PROXY_KEY
    
    def key(self, name):
        return '{key}:{name}'.format(key=self.proxy_key, name=name)
    
    def set(self, name, proxy):
        return self.db.set(self.key(name), proxy)

    def get(self, name):
        return self.db.get(self.key(name)).decode('utf-8')
```

首先初始化Redis连接，我们可以将Key设计成`adsl:vm1`这种形式，冒号前面是总的key，冒号后面是主机名称name，这样显得结构更加清晰。

然后指定set()和get()方法，用来存储代理和获取代理。

#### 请求处理

拨号主机会一直向远程主机发送请求，远程主机当然可以获取拨号主机的IP，但是代理端口是无法获得的，我们在拨号主机上设置了TinyProxy或者Squid，但是服务器不知道是在哪个端口开的，所以端口也是需要客户端传给远程主机的。远程主机接收到请求后，将解析得到的IP和端口合并就可以作为完整的代理保存了。

所以现在我们知道拨号主机需要传送给远程主机的信息已经有两个了，一是拨号主机本身的名称，二是代理的端口。

#### 通信秘钥

为了保证远程主机不被恶意的请求干扰，可以设置一个传输秘钥，最简单的方式可以二者共同规定一个秘钥字符串，拨号主机在传送这个字符串，远程主机匹配一下，如果能正确匹配，那就进行下一步的处理，如果不能匹配，那么可能是恶意请求，就忽略这个请求。

当然肯定有更好的加密传输方式，但为了方便起见可以用如上来做。

所以客户机还需要传送一个数据，那就是通信秘钥，一共需要传送三个数据。

所以我们需要架设一个服务器，一直监听客户端的请求，在这里我们用tornado实现。

tornado的安装也非常简单，利用pip安装即可：

```
pip3 install tornado
```

定义一个处理拨号主机请求的方法，在这里我们使用post请求，参考如下。

```python
def post(self):
        token = self.get_body_argument('token', default=None, strip=False)
        port = self.get_body_argument('port', default=None, strip=False)
        name = self.get_body_argument('name', default=None, strip=False)
        if token == TOKEN and port:
            ip = self.request.remote_ip
            proxy = ip + ':' + port
            print('Receive proxy', proxy)
            self.redis.set(name, proxy)
            self.test_proxies()
        elif token != TOKEN:
            self.write('Wrong Token')
        elif not port:
            self.write('No Client Port')
```

远程主机获取请求的token，也就是上面我们所说的通信密钥，保证安全。port是拨号机的代理端口，name是拨号主机的名称。然后我们再获取请求的remote_ip，也就是拨号主机的IP。然后将IP和端口拼合就可以得到拨号主机的完整代理信息了，将其存入数据库即可。

#### 代理检测

在远程主机端我们需要做一下代理检测，如果某个代理不可用了，会及时将其去除，以免出现获取到代理后不可用的情况。

> 注意：在这里在拨号主机端验证是不够的，因为可能突然遇到某个拨号主机宕机的情况，这样拨号主机就不会再向远程主机发送请求，而最后一次得到的代理还会存在于数据库中，所以在远程主机端统一验证比较科学。

验证方式可以定时检测，也可以每收到一次请求检测一次，用获取到的代理来请求某个网站，检测一下是否能访问即可。如果不能，将其从数据库中删除。

#### API

远程主机已经将拨号主机的IP和端口保存下来了，那也就是说，所有的可用的代理已经在远程主机保存了，我们需要提供一个接口来将代理获取下来。

比如我们可以提供这么几个方法，获取所有代理，获取最新代理，获取随机代理等等。

```python
def all(self):
    keys = self.keys()
    proxies = [{'name': key, 'proxy': self.get(key)} for key in keys]
    return proxies

def random(self):
    items = self.all()
    return random.choice(items).get('proxy')

def list(self):
    keys = self.keys()
    proxies = [self.get(key) for key in keys]
    return proxies

def first(self):
    return self.get(self.keys()[0])
```

然后用tornado搭建API服务，如果可以的话还可以绑定一个域名，更加便捷，举例如下：

获取随机代理：

![](./assets/2017-05-19-14-20-16.jpg)

获取最新代理：

![](./assets/2017-05-19-12-36-13.jpg)

获取所有代理：

![](./assets/2017-05-19-12-35-22.jpg)

请求接口获取可用代理即可，比如获取一个随机代理：

```python
import requests

def get_random_proxy():
    try:
        # 远程主机的服务地址
        url = 'http://xxx.xxx.xxx.xxx:8000/random'
        return requests.get(url).text
    except requests.exceptions.ConnectionError:
        return None
```

这样我们拿到的IP都是稳定可用的，而且过段时间重新请求取到的IP就会变化，是一直动态变化的高可用代理。

### 拨号VPS实现

#### 定时拨号

拨号VPS需要每隔一段时间就拨号一次，我们可以直接执行命令行来拨号，那在Python里我们只需要调用一下这个拨号命令就好了。利用subprocess模块调用脚本即可，在这里定义一个变量ADSL_BASH为`adsl-stop;adsl-start`，这就是拨号的脚本。

```python
import subprocess
(status, output) = subprocess.getstatusoutput(ADSL_BASH)
```

通过getstatusoutput方法可以获取脚本的执行状态和输出结果，如果status为0，则证明拨号成功，然后检测一下拨号接口是否获取了IP地址。

执行`ifconfig`命令可以获取当前的IP，我这台主机接口名称叫做ppp0，当然网卡名称可以自己指定，所以将ppp0接口的IP提取出来即可。

```python
def get_ip(self, ifname=ADSL_IFNAME):
    (status, output) = subprocess.getstatusoutput('ifconfig')
    if status == 0:
        pattern = re.compile(ifname + '.*?inet.*?(\d+\.\d+\.\d+\.\d+).*?netmask', re.S)
        result = re.search(pattern, output)
        if result:
            ip = result.group(1)
            return ip
```

如果方法正常返回IP，则证明IP存在，拨号成功，接下来向远程主机发送请求即可，然后sleep一段时间重新再次拨号。
如果方法返回的值为空，那证明IP不存在，我们需要重新拨号。

#### 请求远程主机

发送的时候需要携带这么几个信息，一个是通信秘钥，一个是代理端口，另一个是主机的标识符，用requests发送即可。

```python
requests.post(SERVER_URL, data={'token': TOKEN, 'port': PROXY_PORT, 'name': CLIENT_NAME})
```

所以整体的思路实现可以写成这样子：

```python
def adsl(self):
        while True:
            print('ADSL Start, Please wait')
            (status, output) = subprocess.getstatusoutput(ADSL_BASH)
            if status == 0:
                print('ADSL Successfully')
                ip = self.get_ip()
                if ip:
                    print('New IP', ip)
                    try:
                        requests.post(SERVER_URL, data={'token': TOKEN, 'port': PROXY_PORT, 'name': CLIENT_NAME})
                        print('Successfully Sent to Server', SERVER_URL)
                    except ConnectionError:
                        print('Failed to Connect Server', SERVER_URL)
                    time.sleep(ADSL_CYCLE)
                else:
                    print('Get IP Failed')
            else:
                print('ADSL Failed, Please Check')
            time.sleep(1)
```

这样我们就可以做到定时拨号并向远程主机发送请求了。

## 代码

Talk is cheap, show me the code! 在这里提供一份完整代码实现，其中client模块是在动态VPS主机运行，server模块在远程主机运行，具体的操作使用可以参考README。

[ADSLProxyPool](https://github.com/Germey/ADSLProxyPool)


